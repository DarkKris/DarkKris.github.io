---
layout: post
title: "NOIp2009TG T2/Luogu P1072 Hankson的趣味题 解题报告"
date: 2016-10-10 
description: "OI解题报告，Hankson的趣味题"
tag: OI解题报告
--- 

> 按照规矩，先来看一下题目

题目描述
----

Hanks 博士是 BT (Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现

在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 c1 和 c2 的最大公约数和最小公倍数。现

在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公

倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 a0,a1,b0,b1，设某未知正整

数 x 满足：

1． x 和 a0 的最大公约数是 a1；

2． x 和 b0 的最小公倍数是 b1。

Hankson 的“逆问题”就是求出满足条件的正整数 x。但稍加思索之后，他发现这样的

x 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 x 的个数。请你帮

助他编程求解这个问题。

输入输出格式
------

**输入格式：**
第一行为一个正整数 n，表示有 n 组输入数据。接下来的 n 行每

行一组输入数据，为四个正整数 a0，a1，b0，b1，每两个整数之间用一个空格隔开。输入

数据保证 a0 能被 a1 整除，b1 能被 b0 整除。

**输出格式：**
输出文件 son.out 共 n 行。每组输入数据的输出结果占一行，为一个整数。

对于每组数据：若不存在这样的 x，请输出 0；

若存在这样的 x，请输出满足条件的 x 的个数；

输入输出样例
------

**输入样例#1：**
2 
41 1 96 288 
95 1 37 1776 
**输出样例#1：**
6 
2

说明
--

**【说明】**

第一组输入数据，x 可以是 9、18、36、72、144、288，共有 6 个。

第二组输入数据，x 可以是 48、1776，共有 2 个。

**【数据范围】**

对于 50%的数据，保证有 1≤a0，a1，b0，b1≤10000 且 n≤100。

对于 100%的数据，保证有 1≤a0，a1，b0，b1≤2,000,000,000 且 n≤2000。

解题思路
----

**数论**

分析一下题目，题目就告诉我们两个式子：
1. gcd(x,a0)=a1
2. lcm(x,b0)=b1
我们可以根据第一个式子推出:gcd(x/a1,a0/a1)==1
还可以根据第二个式子推出:gcd(b1/b0,b1/x)==1
于是我们就可以枚举b1的约数，并验证一下，如果成立就ans++，最后输出ans。

下面贴上代码：

```c++
#include <iostream>
#include <cstdio>
using namespace std;
int n,x,a0,a1,b0,b1;

int gcd(int a,int b){return b==0?a:gcd(b,a%b);};

bool check(int x){return (gcd(a0/a1,x/a1)==1&&gcd(b1/b0,b1/x)==1)?true:false;}

int main()
{
    cin>>n;
    while(n)
    {
        int ans=0;
        
        cin>>a0>>a1>>b0>>b1;
        if(b1%b0||a0%a1){cout<<0<<endl; n--; continue;};
        for(int i=1;i*i<=b1;i++)
        {
            if(b1%i==0)
            {
                int x=i;
                if(x%a1==0&&check(x))ans++;
                x=b1/i;
                if(x!=i&&x%a1==0&&check(x))ans++;
            }
        }
        cout<<ans<<endl;
        n--;
    }
    return 0;
}
```

> 感谢惠读