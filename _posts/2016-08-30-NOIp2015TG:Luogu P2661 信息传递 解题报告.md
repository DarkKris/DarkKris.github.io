---
layout: post
title: "NOIp2015TG/Luogu P2661 信息传递 解题报告"
date: 2016-08-30 
description: "OI解题报告，信息传递"
tag: 解题报告
--- 

> 说出来都是满满的痛啊，当时博主在考场都没有想过DFS，结果模拟骗分骗到了零分。伤心辣么大！
> 现在博主DFS过了这道题，写个博客让自己记住这个做法。
> 
> 下面来看一下题

题目描述
----

有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

输入输出格式
------

**输入格式：**
输入共2行。

第1行包含1个正整数n表示n个人。

第2行包含n个用空格隔开的正整数T1,T2,……,Tn其中第i个整数Ti示编号为i

的同学的信息传递对象是编号为Ti的同学，Ti≤n且Ti≠i

数据保证游戏一定会结束。

**输出格式：**
输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。

输入输出样例
------

**输入样例#1：**
5
2 4 2 3 1
**输出样例#1：**
3

说明
--

**样例1解释**
![信息传递_来自洛谷](http://cdnv2.luogu.org/upload/pic/1826.png)
游戏的流程如图所示。当进行完第 3 轮游戏后， 4 号玩家会听到 2 号玩家告诉他自

己的生日，所以答案为 3。当然，第 3 轮游戏后， 2 号玩家、 3 号玩家都能从自己的消息

来源得知自己的生日，同样符合游戏结束的条件。

对于 30%的数据， n ≤ 200；

对于 60%的数据， n ≤ 2500；

对于 100%的数据， n ≤ 200000。

***

解题思路
----

**DFS**

C++代码：

```c++
//P26661  Ps.time是保留字
#include <iostream>
#include <cstdio>
using namespace std;
const int maxn=200005;
int n,ans,cclock;//cclock记时间（时间戳）
int v[maxn],timee[maxn];//v记下一个要传递的人，timee记搜到这里的时间
void dfs(int x)
{
	if(timee[x]>0)//如果这个点已经被搜过（有时间标志）
	{
		ans=min(ans,cclock-timee[x]+1);//更新答案
	}else
	{
		if(timee[x]!=-1)//如果这个点没扩展过
		{
			cclock++;//（时间++）
			timee[x]=cclock;
			dfs(v[x]);//继续搜下一个点
		}
	}
	timee[x]=-1;//置已扩展标志
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>v[i];
	ans=maxn;
	//以上是读入和初始化
	for(int i=1;i<=n;i++)
	{
		if(timee[i]==0)//如果没处理过（因为有不止一个连通图）
		{
			dfs(i);
			cclock=0;//从一个节点搜完记得时间变为零
		}
	}
	cout<<ans;//输出答案
	return 0;
}
```

> 希望NOIp2016博主能取得一个好成绩，加油！
> 
> 感谢惠读！
