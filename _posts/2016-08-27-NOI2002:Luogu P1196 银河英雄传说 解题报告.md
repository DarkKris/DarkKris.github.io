---
layout: post
title: "NOI2002/Luogu P1196 银河英雄传说 解题报告"
date: 2016-08-27 
description: "OI解题报告，银河英雄传说"
tag: OI解题报告
--- 

> 开门见山看题目：

题目描述
----

公元五八○一年，地球居民迁移至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

**杨威利**擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域**战场划分成30000列，每列依次编号为1, 2, …,30000。**之后，他把自己的**战舰也依次编号为1, 2, …, 30000，让第i号战舰处于第i列(i = 1, 2, …, 30000)**，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。**合并指令为M i j，含义为让第i号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。**显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些**询问指令：C i j。该指令意思是，询问电脑，杨威利的第i号战舰与第j号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。**作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

最终的决战已经展开，银河的历史又翻过了一页……

输入输出格式
------

**输入格式：**
输入文件galaxy.in的第一行有一个整数T（1<=T<=500,000），表示总共有T条指令。

以下有T行，每行有一条指令。指令有两种格式：

M i j ：i和j是两个整数（1<=i , j<=30000），表示指令涉及的战舰编号。
该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第i号战舰与第j号战舰不在同一列。

C i j ：i和j是两个整数（1<=i , j<=30000），表示指令涉及的战舰编号。
该指令是莱因哈特发布的询问指令。

**输出格式：**
输出文件为galaxy.out。你的程序应当依次对输入的每一条指令进行分析和

**处理：**

如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序
要注意到这一点，但是不要输出任何信息；

如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，示在同一列上，第i 号战舰与第j 号战舰之间布置的战舰数目。如果第i 号战舰与第j号战舰当前不在同一列上，则输出-1。

输入输出样例
------

**输入样例#1：**
4
M 2 3
C 1 2
M 2 4
C 4 2
**输出样例#1：**
-1
1

说明
--

【样例说明】

战舰位置图：表格中阿拉伯数字表示战舰编号
![银河英雄传说](http://cdnv2.luogu.org/upload/pic/53.png)

***

解题思路
----
**并查集**

设：

```c++
int fa[maxn];
    //fa[i]:战舰i的父指针；初始：fa[i]=0}

int b[maxn];
    //b[i]:以i为根的树的结点总数；初始：b[i]=1

int c[maxn];
    //c[i]：战舰i在当前列的相对位置（相对当前列的第一艘战舰）；初始：c[i]=1
```

对于指令：
Ch  n1  n2 

先执行操作：

```c++
   p1=find(n1); //找到n1的根
   p2=find(n2); //找到n2的根
   fa[p1]=p2; //合并p1和p2：p1的父指针指向p2；以p1为首的战舰排在以p2为首的战舰后面
```

1、如果 ch=’M’：将战舰n1所在的列接在战舰n2所在的列后面：

```c++
   c[p1]=b[p2]+1;//修改战舰p1在以p2为首的列中的相对位置
   b[p2]=b[p2]+b[p1];//修改以战舰p2作为根（首）的树的总结点数：战舰n2所在列的战舰数量
```

2、如果ch=’C’：

```c++
if(p1=p2)cout<<abs(c[n1]-c[n2])-1<<endl; //n1 和n2在同一列：输出中间的战舰数量
   else cout<<-1<<endl;
```

**注意！理解难点：abs(c[n1]-c[n2]);**


---

**并查集（路径压缩）代码**

```c++
int find(int x);
{
    if(fa[x]==0)return x;//以0为根，建议以x为根，好理解
    int ret;
    ret=find(fa[x]);
    c[x]=c[x]+c[fa[x]]-1;//修改x在当前列中以find为根的相对位置：递归调用父亲先被压缩修改c。等号右边的c[x]：以fa[x]为根的相对位置；c(fa[x])是以find为根的相对位置；显然压缩后：x相对find的相对位置是：c[x]+c[fa[x]]-1
    fa[x]=ret;
    return ret;
}
```
**注意！理解难点：c[x]+c[fa[x]]-1;**

---

完整代码如下：

```c++
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
const int maxn=30005;
int n,fa[maxn],c[maxn],b[maxn];
int find(int x)
{
	if(fa[x]==0)return x;
	int ret;
	ret=find(fa[x]);
	c[x]=c[x]+c[fa[x]]-1;
	fa[x]=ret;
	return ret;
}
int main()
{
	cin>>n;
	for(int i=1;i<=30000;i++){b[i]=1; c[i]=1;}
	for(int i=1;i<=n;i++)
	{
		int x,y;
		char opt;
		cin>>opt>>x>>y;
		int res1,res2;
		res1=find(x);
		res2=find(y);
		if(opt=='M')
		{
			fa[res1]=res2;
			c[res1]=b[res2]+1;
			b[res2]+=b[res1];
		}else
		{
			if(res1==res2)
				cout<<abs(c[x]-c[y])-1<<endl;
			else cout<<-1<<endl;
		}
	}
	return 0;
}
```

***

> 感谢惠读